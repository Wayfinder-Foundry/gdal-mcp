# v1.1.0 Vector Tool Parity - Implementation Plan

**Branch:** `feat/vector-parity-v1.1`  
**Base:** `main` (includes v1.0.1 advisory prompts)  
**Target:** Q1 2025

---

## Strategic Goals

1. **Feature Parity:** Vector tools match raster capabilities
2. **Composition Testing:** Can models naturally chain operations?
3. **Cross-Domain Reflection:** CRS reflection works for both raster and vector
4. **Educational Foundation:** Workflow guidance resources

---

## Current State Assessment

### Existing Vector Tools
- ✅ **`vector_info`** - Fully implemented with pyogrio/fiona
  - Location: `src/tools/vector/info.py`
  - Returns: driver, CRS, layer_count, geometry_types, feature_count, fields, bounds
  - Status: Production ready

### Placeholder Files
- 📝 **`vector_convert.py`** - 5 lines, placeholder
- 📝 **`vector_reproject.py`** - 5 lines, placeholder

### Gap Analysis (vs Raster Tools)

**Raster tools we have:**
```
✅ raster_info      → metadata inspection
✅ raster_convert   → format conversion (GTiff, COG, PNG, compression, tiling)
✅ raster_reproject → CRS transformation (reflection: crs_datum + resampling)
✅ raster_stats     → band statistics, histograms
```

**Vector tools we need:**
```
📝 vector_info      → EXISTS (enhance?)
🆕 vector_reproject → NEW (match raster pattern, reuse CRS reflection)
🆕 vector_convert   → NEW (Shapefile→GPKG, GeoJSON, etc.)
🆕 vector_clip      → NEW (spatial subsetting)
🆕 vector_buffer    → NEW (proximity analysis)
🆕 vector_simplify  → NEW (geometry simplification)
```

---

## Implementation Phases

### Phase 1: Core Parity Tools (Priority)

#### 1.1 `vector_reproject` 
**Goal:** Match `raster_reproject` pattern, reuse CRS reflection

**Signature:**
```python
@mcp.tool()
async def vector_reproject(
    uri: str,
    output: str,
    dst_crs: str,
    src_crs: str | None = None,
    ctx: Context | None = None,
) -> VectorReprojectResult
```

**Key decisions:**
- Use `pyogrio` or `fiona` for reprojection?
- Does reflection middleware work unchanged? (Yes - same `justify_crs_selection`)
- Tool registration in `src/tools/vector/reproject.py`
- Result model: `VectorReprojectResult` (src_crs, dst_crs, feature_count, bounds)

**Testing:**
- Same CRS → cache hit from raster operations?
- Different vector format input (shapefile, geojson, gpkg)
- Cross-domain: Does raster CRS justification cache work?

---

#### 1.2 `vector_convert`
**Goal:** Format conversion matching `raster_convert` capabilities

**Signature:**
```python
@mcp.tool()
async def vector_convert(
    uri: str,
    output: str,
    driver: str | None = None,  # Auto-detect from extension
    encoding: str = "UTF-8",
    ctx: Context | None = None,
) -> VectorConvertResult
```

**Format support:**
- Shapefile → GeoPackage (common use case)
- GeoJSON ↔ GeoPackage
- KML support
- WKT/WKB outputs

**Key decisions:**
- Do we need compression reflection? (No - resources already cover this)
- Driver auto-detection from file extension
- Encoding handling (UTF-8 default, ISO-8859-1 for legacy shapefiles)

**Resources to leverage:**
- `reference://formats/vector` (if we create it)
- Or just use existing driver documentation

---

### Phase 2: Analysis Tools (Secondary Priority)

#### 2.1 `vector_clip`
**Spatial subsetting by bounding box or geometry**

**Signature:**
```python
@mcp.tool()
async def vector_clip(
    uri: str,
    output: str,
    bounds: list[float] | None = None,  # [minx, miny, maxx, maxy]
    mask: str | None = None,  # Path to clip geometry
    ctx: Context | None = None,
) -> VectorClipResult
```

**Use cases:**
- Extract features within bounding box
- Clip by administrative boundary
- Subset large datasets for processing

---

#### 2.2 `vector_buffer`
**Proximity/buffer analysis**

**Signature:**
```python
@mcp.tool()
async def vector_buffer(
    uri: str,
    output: str,
    distance: float,
    distance_unit: str = "meters",  # or "degrees" for geographic CRS
    resolution: int = 16,  # Segments per quadrant
    ctx: Context | None = None,
) -> VectorBufferResult
```

**Reflection domain?**
- Distance unit reasoning (meters vs degrees)
- Buffer resolution tradeoffs
- **Decision:** Start without reflection, add if needed

---

#### 2.3 `vector_simplify`
**Geometry simplification for web display**

**Signature:**
```python
@mcp.tool()
async def vector_simplify(
    uri: str,
    output: str,
    tolerance: float,
    method: str = "douglas-peucker",  # or "visvalingam"
    preserve_topology: bool = True,
    ctx: Context | None = None,
) -> VectorSimplifyResult
```

**Reflection domain?**
- Simplification method choice
- Tolerance selection reasoning
- **Decision:** Start without reflection, evaluate if needed

---

## Composition Testing Framework

### Research Questions

**Q1: Natural Multi-Step Discovery**
- Task: "Prepare this shapefile for web mapping"
- Expected chain: `vector_reproject(EPSG:3857)` → `vector_simplify()` → `vector_convert(GeoJSON)`
- Measure: Does AI chain without explicit workflow prompt?

**Q2: Cross-Domain Composition**
- Task: "Extract elevation for city boundaries"
- Expected: `vector_reproject()` → `raster_clip(by_vector)` (future v2.x)
- Measure: Does AI recognize vector-raster interaction?

**Q3: Reflection Reuse**
- CRS justified for raster operation
- Same CRS used in vector operation
- Expected: Cache hit, no re-prompting
- Measure: Cache hit rate across domains

### Observability

**Session tracking:**
```python
# Log operation sequences
{
  "session_id": "...",
  "operations": [
    {"tool": "vector_reproject", "params": {...}, "timestamp": "..."},
    {"tool": "vector_simplify", "params": {...}, "timestamp": "..."},
    {"tool": "vector_convert", "params": {...}, "timestamp": "..."}
  ],
  "justifications_referenced": ["crs_datum/sha256:abc123..."]
}
```

**Tracking location:** `.preflight/sessions/{session_id}.json`

---

## Workflow Guidance Resources

### `reference://workflows/vector-prep`
**Common vector data preparation patterns**

```json
{
  "patterns": [
    {
      "name": "web_mapping_prep",
      "description": "Prepare vector data for web display",
      "steps": [
        "Reproject to EPSG:3857 (Web Mercator)",
        "Simplify geometry (tolerance based on zoom level)",
        "Convert to GeoJSON or vector tiles"
      ],
      "typical_sequence": ["vector_reproject", "vector_simplify", "vector_convert"]
    },
    {
      "name": "format_migration",
      "description": "Migrate from Shapefile to modern format",
      "steps": [
        "Convert to GeoPackage (single file, no encoding issues)",
        "Optional: Reproject to common CRS for consistency"
      ],
      "typical_sequence": ["vector_convert", "vector_reproject (optional)"]
    },
    {
      "name": "spatial_subset",
      "description": "Extract features for area of interest",
      "steps": [
        "Clip to bounding box or mask geometry",
        "Reproject to analysis CRS",
        "Convert to working format"
      ],
      "typical_sequence": ["vector_clip", "vector_reproject", "vector_convert"]
    }
  ]
}
```

### `reference://workflows/raster-prep`
**Common raster preparation patterns**

```json
{
  "patterns": [
    {
      "name": "web_serving_prep",
      "description": "Prepare raster for web tile serving",
      "steps": [
        "Reproject to EPSG:3857 (Web Mercator)",
        "Convert to Cloud Optimized GeoTIFF",
        "Add internal tiling and overviews"
      ],
      "typical_sequence": ["raster_reproject", "raster_convert (COG)"]
    }
  ]
}
```

---

## Implementation Order (Recommended)

### Sprint 1: Foundation (Weeks 1-2)
1. ✅ Create feature branch `feat/vector-parity-v1.1`
2. Implement `vector_reproject` (match raster pattern)
3. Test CRS reflection cross-domain (raster → vector cache hit?)
4. Create `VectorReprojectResult` model

### Sprint 2: Format Conversion (Weeks 3-4)
1. Implement `vector_convert`
2. Add driver auto-detection
3. Test common conversions (SHP→GPKG, GeoJSON↔GPKG)
4. Create `VectorConvertResult` model

### Sprint 3: Analysis Tools (Weeks 5-6)
1. Implement `vector_clip`
2. Implement `vector_buffer`
3. Implement `vector_simplify`
4. Create result models for each

### Sprint 4: Composition Testing (Weeks 7-8)
1. Create composition testing framework
2. Run natural discovery tests
3. Document findings
4. Create workflow guidance resources

### Sprint 5: Documentation & Release (Week 9)
1. Update README with vector tools
2. Create vector tool examples
3. Update CHANGELOG for v1.1.0
4. PR review and merge

---

## Success Criteria

### Feature Completeness
- [ ] 5+ vector tools implemented
- [ ] Feature parity with raster tools achieved
- [ ] All tools have result models
- [ ] All tools have tests (unit + integration)

### Reflection Integration
- [ ] `vector_reproject` uses CRS reflection
- [ ] Cache hit rate >80% in multi-operation workflows
- [ ] Cross-domain cache hits demonstrated

### Composition
- [ ] 3+ natural composition examples documented
- [ ] Workflow guidance resources created
- [ ] Session tracking operational
- [ ] Success/failure patterns identified

### Quality
- [ ] Full type safety (mypy strict)
- [ ] Test coverage >80%
- [ ] Documentation complete
- [ ] No breaking changes to v1.0.x

---

## Deferred to v2.x

**Why defer these:**
- Specialized use cases
- Require composition patterns proven first
- More complex reflection domains

**Deferred items:**
- `raster_zonal_stats` (vector zones + raster analysis)
- `raster_fill_sinks` (hydrology conditioning)
- Deep analysis tools (terrain derivatives, viewshed)
- Vector-raster intersection tools

---

## Notes

**Advisory Prompting:**
All new tools should follow the advisory pattern established in v1.0.1:
- Conversational intervention over blocking
- Respect user explicit choices
- Educational guidance when appropriate

**Reflection Reuse:**
`vector_reproject` is the key test for cross-domain reflection:
- Uses same `justify_crs_selection` prompt
- Should hit cache from raster operations
- Validates reflection architecture

**Resources First:**
Before adding new reflection domains, check if resources already cover it:
- Format selection → covered by existing compression/format resources
- Distance units → simple validation, not reflection-worthy
- Simplification methods → educational resource, not blocking reflection

---

**Status:** Planning phase  
**Next Action:** Implement `vector_reproject` to test cross-domain reflection
