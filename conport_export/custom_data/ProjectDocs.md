# Custom Data: ProjectDocs

### design/architecture

*   [2025-09-18 01:41:05]

```json
{
  "content": "---\ntype: product_context\ntitle: Architecture\ntags: [design, architecture, product_context]\n---\n\n# Architecture\n\n## System Overview\n\nThe server is built on FastMCP and exposes a small set of GDAL 3.11 unified CLI commands as MCP tools. FastMCP handles JSON\u2011RPC routing, schema generation from type hints/docstrings, and transports (stdio, HTTP). We focus on parameter validation, safe subprocess execution, and clear, structured results.\n\nCore runtime pieces include:\n\n1. **JSON\u2011RPC server.** FastMCP runs over stdio (default) or HTTP. We register tool handlers in the `tools` namespace.\n2. **Tool wrappers.** Each GDAL CLI command is wrapped by an async function that assembles CLI args, executes via `gdal_mcp.utils.run_gdal()`, and returns structured output (parsed JSON or text plus stderr summary). Errors surface with concise messages.\n3. **Resource publication (planned).** For file\u2011producing tools, we will register outputs as MCP resources with metadata; the current implementation returns output paths and stderr.\n4. **Consent & safety.** All executions rely on host\u2011side user approval (FastMCP confirmation). Logging goes to stderr only.\n\n## Module Layout (current)\n\n```\ngdal_mcp/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py           # Typer CLI: `gdal-mcp serve --transport [stdio|http]`\n\u251c\u2500\u2500 app.py                # Shared FastMCP instance `mcp`\n\u251c\u2500\u2500 server.py             # Loader: imports tool modules so @mcp.tool registers\n\u251c\u2500\u2500 utils.py              # Async GDAL subprocess helper (run_gdal)\n\u251c\u2500\u2500 ingest.py             # Docs \u2192 conport_export/ emitter\n\u251c\u2500\u2500 bench.py              # Minimal bench harness (reproject smoke)\n\u2514\u2500\u2500 tools/\n    \u251c\u2500\u2500 __init__.py       # Imports submodules to register tools\n    \u251c\u2500\u2500 info.py           # info() \u2192 `gdal info`\n    \u251c\u2500\u2500 convert.py        # convert() \u2192 `gdal convert`\n    \u2514\u2500\u2500 raster/\n        \u2514\u2500\u2500 reproject.py  # reproject() \u2192 `gdal raster reproject`\n```\n\n- `__main__.py` exposes the `serve` command and starts FastMCP with the chosen transport.\n- `server.py` imports `gdal_mcp.tools` so all `@mcp.tool` functions register at import time.\n- `utils.py` centralizes subprocess execution and error capture for GDAL CLI calls.\n- `tools/` are hierarchical modules, but MCP tool names are flat: `info`, `convert`, `reproject`.\n\n## Execution Lifecycle\n\n1. Client connects and negotiates capabilities (handled by FastMCP).\n2. Client lists tools (`tools/list`) and calls a tool with validated arguments (`tools/call`).\n3. Wrapper builds the GDAL CLI command and runs it with `run_gdal()`.\n4. On success, structured results are returned; on failure, a clear error is raised.\n\n## Security & Trust\n\n- **Least privilege:** Only subprocess execution; no stdout logging, no implicit filesystem writes outside user\u2011provided paths.\n- **Consent:** Hosts must obtain user approval before any tool call.\n- **Validation:** Type\u2011hinted inputs map to generated schemas; wrappers avoid mutating state unless explicitly requested (e.g., `--overwrite`).\n\n## Observability\n\n- **Logging:** Structured logs to stderr with levels (configurable via CLI log level).\n- **Benchmarks:** `bench.py` provides a smoke reprojection run for quick timing.\n\n## Extensibility\n\n- Add new wrappers under `gdal_mcp/tools/` (or a subgroup) and decorate with `@mcp.tool`.\n- For overlapping names (e.g., vector `reproject`), adopt dotted names like `raster.reproject`/`vector.reproject` to retain uniqueness.\n",
  "path": "docs/design/architecture.md",
  "tags": [
    "design",
    "architecture",
    "product_context"
  ],
  "title": "Architecture",
  "type": "product_context"
}
```

---
### design/architecture

*   [2025-09-18 01:41:05]

*   [2025-09-27 20:29:35]

```json
{
  "content": "---\ntype: product_context\ntitle: Architecture\ntags: [design, architecture, product_context]\n---\n\n# Architecture\n\n## System Overview\n\nThe server is built on FastMCP and exposes a small set of GDAL 3.11 unified CLI commands as MCP tools. FastMCP handles JSON\u2011RPC routing, schema generation from type hints/docstrings, and transports (stdio, HTTP). We focus on parameter validation, safe subprocess execution, and clear, structured results.\n\nCore runtime pieces include:\n\n1. **JSON\u2011RPC server.** FastMCP runs over stdio (default) or HTTP. We register tool handlers in the `tools` namespace.\n2. **Tool wrappers.** Each GDAL CLI command is wrapped by an async function that assembles CLI args, executes via `gdal_mcp.utils.run_gdal()`, and returns structured output (parsed JSON or text plus stderr summary). Errors surface with concise messages.\n3. **Resource publication (planned).** For file\u2011producing tools, we will register outputs as MCP resources with metadata; the current implementation returns output paths and stderr.\n4. **Consent & safety.** All executions rely on host\u2011side user approval (FastMCP confirmation). Logging goes to stderr only.\n\n## Module Layout (current)\n\n```\ngdal_mcp/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 __main__.py           # Typer CLI: `gdal-mcp serve --transport [stdio|http]`\n\u251c\u2500\u2500 app.py                # Shared FastMCP instance `mcp`\n\u251c\u2500\u2500 server.py             # Loader: imports tool modules so @mcp.tool registers\n\u251c\u2500\u2500 utils.py              # Async GDAL subprocess helper (run_gdal)\n\u251c\u2500\u2500 ingest.py             # Docs \u2192 conport_export/ emitter\n\u251c\u2500\u2500 bench.py              # Minimal bench harness (reproject smoke)\n\u2514\u2500\u2500 tools/\n    \u251c\u2500\u2500 __init__.py       # Imports submodules to register tools\n    \u251c\u2500\u2500 info.py           # info() \u2192 `gdal info`\n    \u251c\u2500\u2500 convert.py        # convert() \u2192 `gdal convert`\n    \u2514\u2500\u2500 raster/\n        \u2514\u2500\u2500 reproject.py  # reproject() \u2192 `gdal raster reproject`\n```\n\n- `__main__.py` exposes the `serve` command and starts FastMCP with the chosen transport.\n- `server.py` imports `gdal_mcp.tools` so all `@mcp.tool` functions register at import time.\n- `utils.py` centralizes subprocess execution and error capture for GDAL CLI calls.\n- `tools/` are hierarchical modules, but MCP tool names are flat: `info`, `convert`, `reproject`.\n\n## Execution Lifecycle\n\n1. Client connects and negotiates capabilities (handled by FastMCP).\n2. Client lists tools (`tools/list`) and calls a tool with validated arguments (`tools/call`).\n3. Wrapper builds the GDAL CLI command and runs it with `run_gdal()`.\n4. On success, structured results are returned; on failure, a clear error is raised.\n\n## Security & Trust\n\n- **Least privilege:** Only subprocess execution; no stdout logging, no implicit filesystem writes outside user\u2011provided paths.\n- **Consent:** Hosts must obtain user approval before any tool call.\n- **Validation:** Type\u2011hinted inputs map to generated schemas; wrappers avoid mutating state unless explicitly requested (e.g., `--overwrite`).\n\n## Observability\n\n- **Logging:** Structured logs to stderr with levels (configurable via CLI log level).\n- **Benchmarks:** `bench.py` provides a smoke reprojection run for quick timing.\n\n## Extensibility\n\n- Add new wrappers under `gdal_mcp/tools/` (or a subgroup) and decorate with `@mcp.tool`.\n- For overlapping names (e.g., vector `reproject`), adopt dotted names like `raster.reproject`/`vector.reproject` to retain uniqueness.\n",
  "path": "docs/design/architecture.md",
  "tags": [
    "design",
    "architecture",
    "product_context"
  ],
  "title": "Architecture",
  "type": "product_context"
}
```

---
### design/distribution

*   [2025-09-18 01:41:28]

```json
{
  "content": "---\ntype: product_context\ntitle: Distribution Strategy\ntags: [distribution, uvx, docker, product_context]\n---\n\n# Distribution Strategy\n\nShipping the GDAL MCP consistently across environments is as important as implementing the tools themselves. This plan highlights two first-class distribution paths\u2014`uvx` and Docker\u2014alongside release automation and repository structure guidance.\n\n## Repository Layout\n\nThe project keeps a familiar open-source layout to welcome contributors and automation\u3010352695461642380\u2020L160-L169\u3011:\n\n```\ngdal-mcp/\n\u251c\u2500\u2500 README.md             # Overview and quick-start guides\n\u251c\u2500\u2500 LICENSE               # MIT licence\n\u251c\u2500\u2500 CONTRIBUTING.md       # Contribution process\n\u251c\u2500\u2500 CODE_OF_CONDUCT.md    # Community expectations\n\u251c\u2500\u2500 docs/                 # Design notes (this folder) and usage docs\n\u251c\u2500\u2500 gdal_mcp/             # FastMCP server implementation and tool wrappers\n\u251c\u2500\u2500 test/                 # Unit and integration coverage and fixtures\n\u2514\u2500\u2500 pyproject.toml        # Project metadata for uv/uvx and packaging\n```\n\nThis structure makes it straightforward to package the project with modern Python tooling while keeping documentation close to the code.\n\n## `uvx` Distribution\n\n`uvx` offers a zero-install launcher for Python applications. By publishing the GDAL MCP as a Python package, users can execute the server directly with `uvx gdal-mcp` without pre-installing dependencies.\n\nImplementation details:\n\n1. **Packaging metadata.** Use `pyproject.toml` with `project.scripts = { \"gdal-mcp\" = \"gdal_mcp.__main__:main\" }` so `uvx` exposes a console entry point.\n2. **fastMCP integration.** Depend on `fastmcp` and configure the entrypoint to instantiate the GDAL tool set before handing control to fastMCP\u2019s server runner.\n3. **Binary dependencies.** Document that GDAL binaries must be available on the host system. Provide optional scripts that install GDAL via `uv tool install gdal` or system packages.\n4. **Version pinning.** Leverage `uv lock` files to ensure deterministic dependency resolution for both development and runtime.\n5. **Usage docs.** Add a quick-start snippet to the README:\n   ```bash\n   uvx gdal-mcp --workspace /data/projects\n   ```\n   The launcher downloads the wheel, resolves dependencies, and starts the fastMCP server in one step.\n6. **Offline-friendly.** Encourage teams to prime a private `uvx` package index or pre-populate caches when air-gapped deployments are required.\n\nThis approach is ideal for developers who already use `uv` or want an ephemeral environment without managing virtualenvs manually.\n\n## Docker Distribution\n\nDocker remains the easiest way to bundle GDAL native libraries with the MCP server:\n\n1. **Base image.** Start from an official GDAL image or a slim Python image with GDAL installed via `apt`.\n2. **Layering.** Copy the packaged wheel (built during CI) into the container and install it with `pip` or `uv pip install`. Include healthcheck scripts and default configuration.\n3. **Runtime.** Expose the fastMCP HTTP port and mount a workspace volume for input/output datasets.\n4. **Publishing.** Push versioned images to a registry so that users can run `docker run ghcr.io/org/gdal-mcp:latest` and obtain a consistent environment.\n\nCombining Docker with `uvx` lets teams choose between light-weight local execution and fully isolated containers.\n\n## Release Automation\n\n1. **Continuous Integration.** Configure GitHub Actions to run tests, linting, and sample tool invocations on every pull request.\n2. **Tagged releases.** When tagging a release, CI should build wheels, generate the Docker image, run smoke tests, and publish artefacts to PyPI and the container registry.\n3. **Changelog management.** Maintain `CHANGELOG.md` so users can trace tool additions, schema updates, and dependency changes across releases.\n\n## Local Development\n\n- Use `uv` for dependency management (`uv sync` to install dev requirements and create a managed virtual environment).\n- Provide `uv run` commands in contributor docs so developers can launch the fastMCP server (`uv run gdal-mcp serve --transport stdio`).\n- Document how to run HTTP transport (`uv run gdal-mcp serve --transport http --port 8000`) and how to override GDAL discovery with `GDAL_MCP_GDAL_HOME` if needed.\n- Include sample datasets in `test/data/` for integration testing and documentation examples.\n- Encourage pre-commit hooks (`uv run pre-commit run --all-files`) to enforce formatting and schema linting before pushing changes.\n\nBy centring `uvx` and Docker, the GDAL MCP project delivers a flexible installation experience that mirrors modern Python tooling while respecting GDAL\u2019s native dependencies.\n",
  "path": "docs/design/distribution.md",
  "tags": [
    "distribution",
    "uvx",
    "docker",
    "product_context"
  ],
  "title": "Distribution Strategy",
  "type": "product_context"
}
```

---
### design/distribution

*   [2025-09-18 01:41:28]

*   [2025-09-27 20:29:35]

```json
{
  "content": "---\ntype: product_context\ntitle: Distribution Strategy\ntags: [distribution, uvx, docker, product_context]\n---\n\n# Distribution Strategy\n\nShipping the GDAL MCP consistently across environments is as important as implementing the tools themselves. This plan highlights two first-class distribution paths\u2014`uvx` and Docker\u2014alongside release automation and repository structure guidance.\n\n## Repository Layout\n\nThe project keeps a familiar open-source layout to welcome contributors and automation\u3010352695461642380\u2020L160-L169\u3011:\n\n```\ngdal-mcp/\n\u251c\u2500\u2500 README.md             # Overview and quick-start guides\n\u251c\u2500\u2500 LICENSE               # MIT licence\n\u251c\u2500\u2500 CONTRIBUTING.md       # Contribution process\n\u251c\u2500\u2500 CODE_OF_CONDUCT.md    # Community expectations\n\u251c\u2500\u2500 docs/                 # Design notes (this folder) and usage docs\n\u251c\u2500\u2500 gdal_mcp/             # FastMCP server implementation and tool wrappers\n\u251c\u2500\u2500 test/                 # Unit and integration coverage and fixtures\n\u2514\u2500\u2500 pyproject.toml        # Project metadata for uv/uvx and packaging\n```\n\nThis structure makes it straightforward to package the project with modern Python tooling while keeping documentation close to the code.\n\n## `uvx` Distribution\n\n`uvx` offers a zero-install launcher for Python applications. By publishing the GDAL MCP as a Python package, users can execute the server directly with `uvx gdal-mcp` without pre-installing dependencies.\n\nImplementation details:\n\n1. **Packaging metadata.** Use `pyproject.toml` with `project.scripts = { \"gdal-mcp\" = \"gdal_mcp.__main__:main\" }` so `uvx` exposes a console entry point.\n2. **fastMCP integration.** Depend on `fastmcp` and configure the entrypoint to instantiate the GDAL tool set before handing control to fastMCP\u2019s server runner.\n3. **Binary dependencies.** Document that GDAL binaries must be available on the host system. Provide optional scripts that install GDAL via `uv tool install gdal` or system packages.\n4. **Version pinning.** Leverage `uv lock` files to ensure deterministic dependency resolution for both development and runtime.\n5. **Usage docs.** Add a quick-start snippet to the README:\n   ```bash\n   uvx gdal-mcp --workspace /data/projects\n   ```\n   The launcher downloads the wheel, resolves dependencies, and starts the fastMCP server in one step.\n6. **Offline-friendly.** Encourage teams to prime a private `uvx` package index or pre-populate caches when air-gapped deployments are required.\n\nThis approach is ideal for developers who already use `uv` or want an ephemeral environment without managing virtualenvs manually.\n\n## Docker Distribution\n\nDocker remains the easiest way to bundle GDAL native libraries with the MCP server:\n\n1. **Base image.** Start from an official GDAL image or a slim Python image with GDAL installed via `apt`.\n2. **Layering.** Copy the packaged wheel (built during CI) into the container and install it with `pip` or `uv pip install`. Include healthcheck scripts and default configuration.\n3. **Runtime.** Expose the fastMCP HTTP port and mount a workspace volume for input/output datasets.\n4. **Publishing.** Push versioned images to a registry so that users can run `docker run ghcr.io/org/gdal-mcp:latest` and obtain a consistent environment.\n\nCombining Docker with `uvx` lets teams choose between light-weight local execution and fully isolated containers.\n\n## Release Automation\n\n1. **Continuous Integration.** Configure GitHub Actions to run tests, linting, and sample tool invocations on every pull request.\n2. **Tagged releases.** When tagging a release, CI should build wheels, generate the Docker image, run smoke tests, and publish artefacts to PyPI and the container registry.\n3. **Changelog management.** Maintain `CHANGELOG.md` so users can trace tool additions, schema updates, and dependency changes across releases.\n\n## Local Development\n\n- Use `uv` for dependency management (`uv sync` to install dev requirements and create a managed virtual environment).\n- Provide `uv run` commands in contributor docs so developers can launch the fastMCP server (`uv run gdal-mcp serve --transport stdio`).\n- Document how to run HTTP transport (`uv run gdal-mcp serve --transport http --port 8000`) and how to override GDAL discovery with `GDAL_MCP_GDAL_HOME` if needed.\n- Include sample datasets in `test/data/` for integration testing and documentation examples.\n- Encourage pre-commit hooks (`uv run pre-commit run --all-files`) to enforce formatting and schema linting before pushing changes.\n\nBy centring `uvx` and Docker, the GDAL MCP project delivers a flexible installation experience that mirrors modern Python tooling while respecting GDAL\u2019s native dependencies.\n",
  "path": "docs/design/distribution.md",
  "tags": [
    "distribution",
    "uvx",
    "docker",
    "product_context"
  ],
  "title": "Distribution Strategy",
  "type": "product_context"
}
```

---
### design/overview

*   [2025-09-18 01:40:46]

```json
{
  "content": "---\ntype: product_context\ntitle: GDAL MCP Overview\ntags: [design, overview, product_context]\n---\n\n# GDAL MCP Overview\n\n## Purpose\n\nThe **Geospatial Data Abstraction Library (GDAL)** is an open-source translator library for raster and vector geospatial data formats that powers a broad ecosystem of remote-sensing and GIS tooling\u3010666650857824669\u2020L25-L33\u3011. The **Model Context Protocol (MCP)** connects AI models to external systems through JSON-RPC 2.0 and formalises how tools and resources are described and invoked\u3010326596536680505\u2020L84-L173\u3011. This project proposes a **GDAL MCP server** so that agents can trigger GDAL workflows under human supervision while following MCP security guarantees.\n\nWe intend to build on the **fastMCP** reference server. The framework already implements the MCP handshake, JSON-RPC routing, and a structured confirmation workflow, allowing the GDAL tooling to focus on parameter validation, subprocess execution, and resource publication instead of recreating the transport layer from scratch. fastMCP also makes it easy to ship a consistent developer experience across local and hosted deployments.\n\n## Goals\n\n1. **Expose GDAL utilities as MCP tools.** Each GDAL CLI command will be mapped to an MCP tool with precise JSON Schemas so that agents understand the required parameters and the shape of responses.\n2. **Ensure secure, human-centred execution.** Tool invocations must surface friendly confirmation prompts, enforce path whitelisting, and log actions for auditing in line with MCP guidance\u3010555906160256464\u2020L154-L181\u3011.\n3. **Adopt a modular architecture.** Python wrappers will isolate command construction, validation, execution, and result handling to simplify adding new tools or adjusting behaviours over time.\n4. **Support collaborative open source development.** The repository will remain MIT-licensed and include contribution guides, testing workflows, and automation hooks that streamline community participation.\n\n## Use Cases\n\n- **Data inspection.** Analysts can call `info` (GDAL `gdal info`) from an MCP-aware client to verify dataset quality without leaving their workspace.\n- **Format conversion.** Agents convert rasters to COG, JPEG, or NetCDF via `convert` (GDAL `gdal convert`), piping results back as MCP resources for follow-up processing.\n- **Spatial operations.** Complex workflows\u2014mosaicking, reprojection (`reproject` \u2192 GDAL `gdal raster reproject`), rasterising vectors\u2014execute under supervision while retaining a complete audit trail.\n- **Automation guardrails.** Teams embed GDAL steps inside wider agent flows (e.g., report generation) while ensuring every invocation passes through fastMCP\u2019s confirmation gate.\n\n## Stakeholders & Responsibilities\n\n- **Core maintainers** own architecture, release management, and schema evolution.\n- **Contributors** propose new tool wrappers or improvements by following the testing and documentation guidelines in `docs/design/`.\n- **Operators** deploy the packaged server via `uvx` or Docker, configure workspaces, and monitor observability signals.\n- **Agent builders** integrate the MCP endpoints into their assistants, relying on the documented contracts and resources.\n\n## Non-Goals\n\n- Rewriting or modifying GDAL core functionality; we wrap stable CLI commands instead.\n- Providing a long-running job queue or distributed execution platform in the initial release.\n- Shipping bespoke GIS visualisations\u2014outputs are delivered as files or structured JSON for downstream tools.\n\n## Success Metrics\n\n- **Reliability.** \u226599% success rate across CI integration runs and smoke tests for supported tools.\n- **Safety.** Zero confirmed incidents of unauthorised filesystem access thanks to enforced whitelists and confirmations.\n- **Adoption.** External contributors add or enhance tool wrappers following the documented processes.\n- **Portability.** Users can launch the server locally with `uvx` or in Docker with identical behaviour.\n\n## Document Map\n\nTo keep the design approachable, the content is split into focused documents:\n\n- [Architecture](architecture.md) \u2014 how the fastMCP-based server is composed, including data flow and security controls.\n- [Tool Specifications](tools.md) \u2014 JSON Schemas and behavioural notes for each GDAL command we intend to expose.\n- [Testing & QA Strategy](testing.md) \u2014 validation approach to keep schemas, consent flows, and binaries reliable.\n- [Distribution Strategy](distribution.md) \u2014 how to package and ship the server via `uvx`, Docker, and automated releases.\n\nEach document is self-contained but builds toward a cohesive GDAL MCP implementation.\n",
  "path": "docs/design/overview.md",
  "tags": [
    "design",
    "overview",
    "product_context"
  ],
  "title": "GDAL MCP Overview",
  "type": "product_context"
}
```

---
### design/overview

*   [2025-09-18 01:40:46]

*   [2025-09-27 20:29:35]

```json
{
  "content": "---\ntype: product_context\ntitle: GDAL MCP Overview\ntags: [design, overview, product_context]\n---\n\n# GDAL MCP Overview\n\n## Purpose\n\nThe **Geospatial Data Abstraction Library (GDAL)** is an open-source translator library for raster and vector geospatial data formats that powers a broad ecosystem of remote-sensing and GIS tooling\u3010666650857824669\u2020L25-L33\u3011. The **Model Context Protocol (MCP)** connects AI models to external systems through JSON-RPC 2.0 and formalises how tools and resources are described and invoked\u3010326596536680505\u2020L84-L173\u3011. This project proposes a **GDAL MCP server** so that agents can trigger GDAL workflows under human supervision while following MCP security guarantees.\n\nWe intend to build on the **fastMCP** reference server. The framework already implements the MCP handshake, JSON-RPC routing, and a structured confirmation workflow, allowing the GDAL tooling to focus on parameter validation, subprocess execution, and resource publication instead of recreating the transport layer from scratch. fastMCP also makes it easy to ship a consistent developer experience across local and hosted deployments.\n\n## Goals\n\n1. **Expose GDAL utilities as MCP tools.** Each GDAL CLI command will be mapped to an MCP tool with precise JSON Schemas so that agents understand the required parameters and the shape of responses.\n2. **Ensure secure, human-centred execution.** Tool invocations must surface friendly confirmation prompts, enforce path whitelisting, and log actions for auditing in line with MCP guidance\u3010555906160256464\u2020L154-L181\u3011.\n3. **Adopt a modular architecture.** Python wrappers will isolate command construction, validation, execution, and result handling to simplify adding new tools or adjusting behaviours over time.\n4. **Support collaborative open source development.** The repository will remain MIT-licensed and include contribution guides, testing workflows, and automation hooks that streamline community participation.\n\n## Use Cases\n\n- **Data inspection.** Analysts can call `info` (GDAL `gdal info`) from an MCP-aware client to verify dataset quality without leaving their workspace.\n- **Format conversion.** Agents convert rasters to COG, JPEG, or NetCDF via `convert` (GDAL `gdal convert`), piping results back as MCP resources for follow-up processing.\n- **Spatial operations.** Complex workflows\u2014mosaicking, reprojection (`reproject` \u2192 GDAL `gdal raster reproject`), rasterising vectors\u2014execute under supervision while retaining a complete audit trail.\n- **Automation guardrails.** Teams embed GDAL steps inside wider agent flows (e.g., report generation) while ensuring every invocation passes through fastMCP\u2019s confirmation gate.\n\n## Stakeholders & Responsibilities\n\n- **Core maintainers** own architecture, release management, and schema evolution.\n- **Contributors** propose new tool wrappers or improvements by following the testing and documentation guidelines in `docs/design/`.\n- **Operators** deploy the packaged server via `uvx` or Docker, configure workspaces, and monitor observability signals.\n- **Agent builders** integrate the MCP endpoints into their assistants, relying on the documented contracts and resources.\n\n## Non-Goals\n\n- Rewriting or modifying GDAL core functionality; we wrap stable CLI commands instead.\n- Providing a long-running job queue or distributed execution platform in the initial release.\n- Shipping bespoke GIS visualisations\u2014outputs are delivered as files or structured JSON for downstream tools.\n\n## Success Metrics\n\n- **Reliability.** \u226599% success rate across CI integration runs and smoke tests for supported tools.\n- **Safety.** Zero confirmed incidents of unauthorised filesystem access thanks to enforced whitelists and confirmations.\n- **Adoption.** External contributors add or enhance tool wrappers following the documented processes.\n- **Portability.** Users can launch the server locally with `uvx` or in Docker with identical behaviour.\n\n## Document Map\n\nTo keep the design approachable, the content is split into focused documents:\n\n- [Architecture](architecture.md) \u2014 how the fastMCP-based server is composed, including data flow and security controls.\n- [Tool Specifications](tools.md) \u2014 JSON Schemas and behavioural notes for each GDAL command we intend to expose.\n- [Testing & QA Strategy](testing.md) \u2014 validation approach to keep schemas, consent flows, and binaries reliable.\n- [Distribution Strategy](distribution.md) \u2014 how to package and ship the server via `uvx`, Docker, and automated releases.\n\nEach document is self-contained but builds toward a cohesive GDAL MCP implementation.\n",
  "path": "docs/design/overview.md",
  "tags": [
    "design",
    "overview",
    "product_context"
  ],
  "title": "GDAL MCP Overview",
  "type": "product_context"
}
```

---
### design/testing

*   [2025-09-18 01:42:05]

```json
{
  "content": "---\ntype: product_context\ntitle: Testing & QA Strategy\ntags: [design, testing, qa, product_context]\n---\n\n# Testing & QA Strategy\n\nMaintaining trust in the GDAL MCP server requires disciplined validation across function signatures, subprocess command composition, runtime contracts, and distribution artefacts. This guide captures the quality approach for contributors.\n\n## Guiding Principles\n\n- **Reproducibility first.** Deterministic tests with pinned deps, small fixtures, and isolated temp dirs.\n- **FastMCP parity.** Preserve compatibility with FastMCP transports (stdio/http), confirmation, and error envelopes.\n- **Shift-left validation.** Validate function inputs and CLI argument assembly before invoking GDAL.\n- **Security preservation.** Exercise consent flows and path validation to uphold MCP security guidelines.\n- **Automation friendly.** All checks run in CI with clear pass/fail signals and uploaded logs.\n\n## Test Layers\n\n### 1. Static & Linting\n\n- `ruff` for style/import hygiene and subprocess safety rules.\n- `mypy` with strict optional on tool modules and helpers (`gdal_mcp/utils.py`).\n- Optional: generate and snapshot FastMCP-derived schemas from type hints to detect breaking changes.\n\n### 2. Unit Tests\n\n- Validate each wrapper\u2019s CLI assembly without calling GDAL (patch `run_gdal`).\n- Confirm defaults and optional parameters are respected.\n- Test error surfacing: non\u2011zero exit codes raise with concise messages.\n\n### 3. Integration Tests\n\n- Start an in\u2011process FastMCP server via `uv run gdal-mcp serve --transport stdio` and use fixtures under `test/data/`.\n- Exercise tools against tiny rasters:\n  - `info` (JSON and text)\n  - `convert` (format + CO options)\n  - `reproject` (dst CRS, resampling)\n- Parametrise edge cases: missing inputs, timeouts, and overwrite paths.\n- For HTTP, assert response envelopes and headers.\n\n### 4. Contract Tests\n\n- Snapshot tool metadata from `tools/list` and diff in CI to catch accidental name/signature changes.\n- Validate example `tools/call` requests and responses for each tool.\n\n### 5. Security & Compliance\n\n- Block directory traversal (`..`) and unexpected absolute paths where applicable.\n- Ensure no stdout prints from server; logs go to stderr.\n- Dependency vuln scanning (`uv audit` or `pip-audit`).\n\n### 6. Performance (Smoke)\n\n- Use `gdal_mcp/bench.py` for a tiny reprojection smoke to track wall time.\n- Record p50/p95 and stderr size to detect regressions.\n\n## Tooling & Automation\n\n- Local: `uv run ruff check`, `uv run mypy`, and `uv run pytest -q`.\n- CI stages: `lint`, `type-check`, `unit`, `integration`, `package-smoke` (build wheel + `uvx gdal-mcp --help`).\n- Failures attach server stderr logs for triage.\n\n## Release Gates\n\n- Green CI, Docker smoke (`gdalinfo --version`), and `uvx gdal-mcp --help` verified.\n- Update `CHANGELOG.md` noting tool signature changes.\n\nAdhering to this strategy keeps the server dependable while enabling rapid iteration across tools and distribution.\n",
  "path": "docs/design/testing.md",
  "tags": [
    "design",
    "testing",
    "qa",
    "product_context"
  ],
  "title": "Testing & QA Strategy",
  "type": "product_context"
}
```

---
### design/testing

*   [2025-09-18 01:42:05]

*   [2025-09-27 20:29:36]

```json
{
  "content": "---\ntype: product_context\ntitle: Testing & QA Strategy\ntags: [design, testing, qa, product_context]\n---\n\n# Testing & QA Strategy\n\nMaintaining trust in the GDAL MCP server requires disciplined validation across function signatures, subprocess command composition, runtime contracts, and distribution artefacts. This guide captures the quality approach for contributors.\n\n## Guiding Principles\n\n- **Reproducibility first.** Deterministic tests with pinned deps, small fixtures, and isolated temp dirs.\n- **FastMCP parity.** Preserve compatibility with FastMCP transports (stdio/http), confirmation, and error envelopes.\n- **Shift-left validation.** Validate function inputs and CLI argument assembly before invoking GDAL.\n- **Security preservation.** Exercise consent flows and path validation to uphold MCP security guidelines.\n- **Automation friendly.** All checks run in CI with clear pass/fail signals and uploaded logs.\n\n## Test Layers\n\n### 1. Static & Linting\n\n- `ruff` for style/import hygiene and subprocess safety rules.\n- `mypy` with strict optional on tool modules and helpers (`gdal_mcp/utils.py`).\n- Optional: generate and snapshot FastMCP-derived schemas from type hints to detect breaking changes.\n\n### 2. Unit Tests\n\n- Validate each wrapper\u2019s CLI assembly without calling GDAL (patch `run_gdal`).\n- Confirm defaults and optional parameters are respected.\n- Test error surfacing: non\u2011zero exit codes raise with concise messages.\n\n### 3. Integration Tests\n\n- Start an in\u2011process FastMCP server via `uv run gdal-mcp serve --transport stdio` and use fixtures under `test/data/`.\n- Exercise tools against tiny rasters:\n  - `info` (JSON and text)\n  - `convert` (format + CO options)\n  - `reproject` (dst CRS, resampling)\n- Parametrise edge cases: missing inputs, timeouts, and overwrite paths.\n- For HTTP, assert response envelopes and headers.\n\n### 4. Contract Tests\n\n- Snapshot tool metadata from `tools/list` and diff in CI to catch accidental name/signature changes.\n- Validate example `tools/call` requests and responses for each tool.\n\n### 5. Security & Compliance\n\n- Block directory traversal (`..`) and unexpected absolute paths where applicable.\n- Ensure no stdout prints from server; logs go to stderr.\n- Dependency vuln scanning (`uv audit` or `pip-audit`).\n\n### 6. Performance (Smoke)\n\n- Use `gdal_mcp/bench.py` for a tiny reprojection smoke to track wall time.\n- Record p50/p95 and stderr size to detect regressions.\n\n## Tooling & Automation\n\n- Local: `uv run ruff check`, `uv run mypy`, and `uv run pytest -q`.\n- CI stages: `lint`, `type-check`, `unit`, `integration`, `package-smoke` (build wheel + `uvx gdal-mcp --help`).\n- Failures attach server stderr logs for triage.\n\n## Release Gates\n\n- Green CI, Docker smoke (`gdalinfo --version`), and `uvx gdal-mcp --help` verified.\n- Update `CHANGELOG.md` noting tool signature changes.\n\nAdhering to this strategy keeps the server dependable while enabling rapid iteration across tools and distribution.\n",
  "path": "docs/design/testing.md",
  "tags": [
    "design",
    "testing",
    "qa",
    "product_context"
  ],
  "title": "Testing & QA Strategy",
  "type": "product_context"
}
```

---
### design/tools

*   [2025-09-18 01:41:50]

```json
{
  "content": "---\ntype: product_context\ntitle: Tool Specifications\ntags: [design, tools, product_context]\n---\n\n# Tool Specifications\n\nThis document defines the current MCP tools exposed by the GDAL MCP server, their parameters, and behaviour. Tools are implemented as Python functions decorated with `@mcp.tool` and live under the hierarchical package `gdal_mcp/tools/`. The MCP tool list is flat, so function names must be unique.\n\n- Module layout:\n  - `gdal_mcp/tools/info.py` \u2192 `info()` wraps `gdal info`\n  - `gdal_mcp/tools/convert.py` \u2192 `convert()` wraps `gdal convert`\n  - `gdal_mcp/tools/raster/reproject.py` \u2192 `reproject()` wraps `gdal raster reproject`\n\nSchemas are generated automatically from type hints and docstrings by FastMCP.\n\n## Conventions\n\n- Paths must be valid on the server host; relative paths are resolved by the GDAL subprocess.\n- Optional arguments are omitted from the CLI unless provided.\n- All logging goes to stderr; returned payloads are structured JSON.\n- Errors raise with a concise message derived from GDAL stderr, surfaced to the MCP host.\n\n---\n\n## info()\n\nWraps: `gdal info`\n\n- Parameters\n  - `path: str` \u2014 Input dataset path or URI\n  - `format: str = \"json\"` \u2014 One of `json`, `text`\n\n- Behaviour\n  - Constructs: `gdal info <path> --format <json|text>`\n  - On success:\n    - If `format=json`, parses stdout to a dict and returns it.\n    - If `format=text`, returns `{ \"text\": <stdout> }`.\n  - On failure: raises `RuntimeError` with GDAL stderr (or stdout fallback).\n\n- Returns (examples)\n  - JSON format: the parsed GDAL info structure\n  - Text format: `{ \"text\": \"...\" }`\n\n---\n\n## convert()\n\nWraps: `gdal convert`\n\n- Parameters\n  - `input: str` \u2014 Source dataset path/URI\n  - `output: str` \u2014 Output path/URI\n  - `output_format: Optional[str] = None` \u2014 Driver short name (e.g., `GTiff`, `COG`, `GPKG`)\n  - `overwrite: bool = True` \u2014 Add `--overwrite`\n  - `creation_options: Optional[Dict[str,str]] = None` \u2014 Emits repeated `--creation-option key=value`\n  - `extra_args: Optional[List[str]] = None` \u2014 Additional CLI switches appended verbatim\n\n- Behaviour\n  - Constructs: `gdal convert <input> <output> [--output-format <drv>] [--overwrite] [--creation-option k=v]* [extra...]`\n  - On success: returns `{ \"output\": <output>, \"stderr\": <err> }` (stderr typically contains GDAL progress/messages)\n  - On failure: raises `RuntimeError` with GDAL stderr\n\n- Notes\n  - Creation options are driver-specific (e.g., `TILED=YES`, `COMPRESS=ZSTD`).\n\n---\n\n## reproject()\n\nWraps: `gdal raster reproject`\n\n- Parameters\n  - `input: str` \u2014 Source raster\n  - `output: str` \u2014 Output raster\n  - `dst_crs: str` \u2014 Destination CRS (e.g., `EPSG:4326`)\n  - `src_crs: Optional[str] = None`\n  - `resampling: Optional[str] = None` \u2014 e.g., `near`, `bilinear`, `cubic`, ...\n  - `resolution: Optional[str] = None` \u2014 `<xres>,<yres>`\n  - `size: Optional[str] = None` \u2014 `<width>,<height>` (mutually exclusive with `resolution`)\n  - `bbox: Optional[str] = None` \u2014 `<xmin>,<ymin>,<xmax>,<ymax>` in `bbox_crs` if set else `dst_crs`\n  - `bbox_crs: Optional[str] = None`\n  - `overwrite: bool = True`\n  - `creation_options: Optional[Dict[str,str]] = None` \u2014 `--creation-option k=v`\n  - `warp_options: Optional[Dict[str,str]] = None` \u2014 `--warp-option k=v`\n  - `transform_options: Optional[Dict[str,str]] = None` \u2014 `--transform-option k=v`\n  - `extra_args: Optional[List[str]] = None`\n\n- Behaviour\n  - Constructs: `gdal raster reproject <input> <output> --dst-crs <dst> [--src-crs <src>] [--resampling <alg>] [--resolution <r>] [--size <w,h>] [--bbox <...>] [--bbox-crs <...>] [--overwrite] [--creation-option k=v]* [--warp-option k=v]* [--transform-option k=v]* [extra...]`\n  - On success: `{ \"output\": <output>, \"stderr\": <err> }`\n  - On failure: raises `RuntimeError` with stderr\n\n- Tips\n  - Use `resolution` OR `size`, not both.\n  - `warp_options` and `transform_options` pass directly to the underlying GDAL warp/transform.\n\n---\n\n## Future candidates (not yet implemented)\n\n- Raster: `overview add/delete`, `clip`, `translate` options expansion.\n- Vector: `info`, `reproject`, `clip`, `convert`.\n\nAdding a tool follows the same pattern: new module under `gdal_mcp/tools/` (or a subgroup), `@mcp.tool` with typed signature, and a subprocess assembly mirroring the GDAL 3.11 CLI.\n",
  "path": "docs/design/tools.md",
  "tags": [
    "design",
    "tools",
    "product_context"
  ],
  "title": "Tool Specifications",
  "type": "product_context"
}
```

---
### design/tools

*   [2025-09-18 01:41:50]

*   [2025-09-27 20:29:36]

```json
{
  "content": "---\ntype: product_context\ntitle: Tool Specifications\ntags: [design, tools, product_context]\n---\n\n# Tool Specifications\n\nThis document defines the current MCP tools exposed by the GDAL MCP server, their parameters, and behaviour. Tools are implemented as Python functions decorated with `@mcp.tool` and live under the hierarchical package `gdal_mcp/tools/`. The MCP tool list is flat, so function names must be unique.\n\n- Module layout:\n  - `gdal_mcp/tools/info.py` \u2192 `info()` wraps `gdal info`\n  - `gdal_mcp/tools/convert.py` \u2192 `convert()` wraps `gdal convert`\n  - `gdal_mcp/tools/raster/reproject.py` \u2192 `reproject()` wraps `gdal raster reproject`\n\nSchemas are generated automatically from type hints and docstrings by FastMCP.\n\n## Conventions\n\n- Paths must be valid on the server host; relative paths are resolved by the GDAL subprocess.\n- Optional arguments are omitted from the CLI unless provided.\n- All logging goes to stderr; returned payloads are structured JSON.\n- Errors raise with a concise message derived from GDAL stderr, surfaced to the MCP host.\n\n---\n\n## info()\n\nWraps: `gdal info`\n\n- Parameters\n  - `path: str` \u2014 Input dataset path or URI\n  - `format: str = \"json\"` \u2014 One of `json`, `text`\n\n- Behaviour\n  - Constructs: `gdal info <path> --format <json|text>`\n  - On success:\n    - If `format=json`, parses stdout to a dict and returns it.\n    - If `format=text`, returns `{ \"text\": <stdout> }`.\n  - On failure: raises `RuntimeError` with GDAL stderr (or stdout fallback).\n\n- Returns (examples)\n  - JSON format: the parsed GDAL info structure\n  - Text format: `{ \"text\": \"...\" }`\n\n---\n\n## convert()\n\nWraps: `gdal convert`\n\n- Parameters\n  - `input: str` \u2014 Source dataset path/URI\n  - `output: str` \u2014 Output path/URI\n  - `output_format: Optional[str] = None` \u2014 Driver short name (e.g., `GTiff`, `COG`, `GPKG`)\n  - `overwrite: bool = True` \u2014 Add `--overwrite`\n  - `creation_options: Optional[Dict[str,str]] = None` \u2014 Emits repeated `--creation-option key=value`\n  - `extra_args: Optional[List[str]] = None` \u2014 Additional CLI switches appended verbatim\n\n- Behaviour\n  - Constructs: `gdal convert <input> <output> [--output-format <drv>] [--overwrite] [--creation-option k=v]* [extra...]`\n  - On success: returns `{ \"output\": <output>, \"stderr\": <err> }` (stderr typically contains GDAL progress/messages)\n  - On failure: raises `RuntimeError` with GDAL stderr\n\n- Notes\n  - Creation options are driver-specific (e.g., `TILED=YES`, `COMPRESS=ZSTD`).\n\n---\n\n## reproject()\n\nWraps: `gdal raster reproject`\n\n- Parameters\n  - `input: str` \u2014 Source raster\n  - `output: str` \u2014 Output raster\n  - `dst_crs: str` \u2014 Destination CRS (e.g., `EPSG:4326`)\n  - `src_crs: Optional[str] = None`\n  - `resampling: Optional[str] = None` \u2014 e.g., `near`, `bilinear`, `cubic`, ...\n  - `resolution: Optional[str] = None` \u2014 `<xres>,<yres>`\n  - `size: Optional[str] = None` \u2014 `<width>,<height>` (mutually exclusive with `resolution`)\n  - `bbox: Optional[str] = None` \u2014 `<xmin>,<ymin>,<xmax>,<ymax>` in `bbox_crs` if set else `dst_crs`\n  - `bbox_crs: Optional[str] = None`\n  - `overwrite: bool = True`\n  - `creation_options: Optional[Dict[str,str]] = None` \u2014 `--creation-option k=v`\n  - `warp_options: Optional[Dict[str,str]] = None` \u2014 `--warp-option k=v`\n  - `transform_options: Optional[Dict[str,str]] = None` \u2014 `--transform-option k=v`\n  - `extra_args: Optional[List[str]] = None`\n\n- Behaviour\n  - Constructs: `gdal raster reproject <input> <output> --dst-crs <dst> [--src-crs <src>] [--resampling <alg>] [--resolution <r>] [--size <w,h>] [--bbox <...>] [--bbox-crs <...>] [--overwrite] [--creation-option k=v]* [--warp-option k=v]* [--transform-option k=v]* [extra...]`\n  - On success: `{ \"output\": <output>, \"stderr\": <err> }`\n  - On failure: raises `RuntimeError` with stderr\n\n- Tips\n  - Use `resolution` OR `size`, not both.\n  - `warp_options` and `transform_options` pass directly to the underlying GDAL warp/transform.\n\n---\n\n## Future candidates (not yet implemented)\n\n- Raster: `overview add/delete`, `clip`, `translate` options expansion.\n- Vector: `info`, `reproject`, `clip`, `convert`.\n\nAdding a tool follows the same pattern: new module under `gdal_mcp/tools/` (or a subgroup), `@mcp.tool` with typed signature, and a subprocess assembly mirroring the GDAL 3.11 CLI.\n",
  "path": "docs/design/tools.md",
  "tags": [
    "design",
    "tools",
    "product_context"
  ],
  "title": "Tool Specifications",
  "type": "product_context"
}
```

---
### guidelines/mcp

*   [2025-09-18 01:43:33]

```json
{
  "content": "---\ntype: product_context\ntitle: MCP Guidelines\ntags: [mcp, compliance, guidelines]\n---\n\n# Guide to Building an MCP Server (Model Context Protocol)\n\n## Introduction\n\nThe **Model Context Protocol (MCP)** is an open standard that allows AI applications (called *hosts*) such as Claude Desktop or ChatGPT to discover context data and safely call functions exposed by external systems.  The protocol decouples AI clients from specific data sources and tools by defining a JSON\u2011RPC\u2013based interface for exchanging context and invoking actions.  An MCP **server** is a program that provides tools, resources and prompts to a host through an **MCP client**.  A **client** is a connector embedded in the host which maintains a dedicated connection to a single server and translates between JSON\u2011RPC messages and host\u2011specific APIs:contentReference[oaicite:0]{index=0}.  Multiple clients can be active within a host to communicate with different servers:contentReference[oaicite:1]{index=1}.\n\nThis guide synthesises the official documentation and specification to provide server developers with a concise reference.  It covers the architecture, lifecycle, primitives, message flows and best practices needed to build a compliant server.\n\n## Architecture and Participants\n\nMCP follows a **client\u2011server architecture** with three actors:contentReference[oaicite:2]{index=2}:\n\n| Actor | Role |\n|---|---|\n| **Host** | The AI application (e.g., IDE, chat\u2011assistant) that spawns clients and orchestrates interactions. |\n| **Client** | A connection manager running inside the host that talks to exactly one server.  It negotiates capabilities, translates user interactions into JSON\u2011RPC requests and enforces user permissions. |\n| **Server** | A separate program that provides context and functionality via MCP.  It may run locally or remotely and communicates only through JSON\u2011RPC messages. |\n\nMCP splits functionality into two **layers**:contentReference[oaicite:3]{index=3}:\n\n1. **Data layer** \u2013 a JSON\u2011RPC 2.0 exchange protocol that defines message structures for connection lifecycle, primitives (tools, resources and prompts), client\u2011initiated features (sampling, elicitation, logging) and notifications.  This layer defines what messages exist and when they are valid:contentReference[oaicite:4]{index=4}.\n2. **Transport layer** \u2013 responsible for moving JSON\u2011RPC messages between participants.  The two official transports are **stdio** (for local processes) and **streamable HTTP** (for remote servers).  StdIO is faster and uses process pipes; HTTP uses POST requests and optional Server\u2011Sent Events for streaming responses, with support for bearer tokens, API keys or OAuth:contentReference[oaicite:5]{index=5}.\n\n### Scope and Projects\n\nThe protocol comprises a specification, SDKs in multiple languages, development tools (e.g., an **MCP Inspector**) and reference servers:contentReference[oaicite:6]{index=6}.  The standard only defines how context and tool calls are exchanged; how the host uses this context (e.g., summarising long documents) is out of scope:contentReference[oaicite:7]{index=7}.\n\n## Lifecycle Management\n\nMCP connections are **stateful**; therefore server and client must negotiate capabilities and protocol version before any operation.  The lifecycle consists of three phases:contentReference[oaicite:8]{index=8}:\n\n1. **Initialisation** \u2013 The client sends an `initialize` request specifying the protocol version it understands, its capabilities (e.g., ability to handle elicitation or sampling) and client metadata:contentReference[oaicite:9]{index=9}.  The server responds with its supported protocol version, capabilities and server metadata:contentReference[oaicite:10]{index=10}.  Once agreed, the client sends a `notifications/initialized` message to signal readiness:contentReference[oaicite:11]{index=11}.  During this phase clients and servers **must not** send other requests apart from pings or logging messages:contentReference[oaicite:12]{index=12}.\n2. **Operation** \u2013 After initialization, both parties can send requests or notifications defined by the capabilities negotiated.  They must use the same protocol version throughout the session:contentReference[oaicite:13]{index=13}.\n3. **Shutdown** \u2013 The connection terminates gracefully.  There are no special shutdown messages; the transport (closing stdio streams or HTTP connections) signals termination:contentReference[oaicite:14]{index=14}.\n\n### Version Negotiation\n\nProtocol revisions are strings like `YYYY\u2011MM\u2011DD` and indicate the last date of backward\u2011incompatible changes:contentReference[oaicite:15]{index=15}.  During initialisation the client proposes a version; if the server supports it, it responds with the same version; otherwise it can reply with the latest version it supports:contentReference[oaicite:16]{index=16}.  If a common version cannot be found, the connection should be closed:contentReference[oaicite:17]{index=17}.  For HTTP transports, every request must include an `MCP\u2011Protocol\u2011Version` header with the negotiated version:contentReference[oaicite:18]{index=18}.\n\n### Capability Negotiation\n\nCapabilities define optional features of the protocol.  During initialisation, the client advertises capabilities it supports (roots, sampling, elicitation, etc.), and the server advertises the features it offers (tools, resources, prompts, logging, completions, etc.):contentReference[oaicite:19]{index=19}.  Each capability can include sub\u2011capabilities like `listChanged` (server will send update notifications) or `subscribe` (client can subscribe to resource changes).  Only capabilities that both sides declare are allowed during the session:contentReference[oaicite:20]{index=20}.\n\n## MCP Primitives \u2013 Server Side\n\nA server exposes **three core primitives**:contentReference[oaicite:21]{index=21}:\n\n1. **Tools** \u2013 Executable functions that perform actions, such as database queries or API calls.  Tools are model\u2011controlled; the language model decides when to call them based on user prompts.  Each tool is described using JSON Schema (input parameters and optional output schema) and is uniquely named:contentReference[oaicite:22]{index=22}.  Tools can be invoked via the `tools/call` method.  Servers may also send `notifications/tools/list_changed` to inform clients when tools are added or removed:contentReference[oaicite:23]{index=23}.  The specification requires that tools be safe \u2013 the host must always seek explicit user approval before executing a tool:contentReference[oaicite:24]{index=24}.\n\n2. **Resources** \u2013 Read\u2011only data that provide context to AI models.  Resources may represent file contents, database records, or API responses.  Each resource has a URI (e.g., `file:///path/to/file.md`) and MIME type.  There are **direct resources**, which have fixed URIs, and **resource templates**, which include parameters (e.g., `travel://activities/{city}/{category}`) to allow flexible queries:contentReference[oaicite:25]{index=25}.  Resources are discovered via `resources/list` or `resources/templates/list` and read via `resources/read`:contentReference[oaicite:26]{index=26}.  Optional `resources/subscribe` allows clients to subscribe to changes:contentReference[oaicite:27]{index=27}.  Servers can use resources to supply context to the model, but the host decides how to select and deliver the data:contentReference[oaicite:28]{index=28}.\n\n3. **Prompts** \u2013 Pre\u2011built templates that guide the model through tasks.  Prompts can have structured arguments and may reference tools and resources to create domain workflows:contentReference[oaicite:29]{index=29}.  They are discovered via `prompts/list` and retrieved with `prompts/get`; they are never auto\u2011invoked by the model and always require explicit user initiation:contentReference[oaicite:30]{index=30}.  Parameter completion helps users discover valid argument values:contentReference[oaicite:31]{index=31}.\n\n### Tool Definition and Usage\n\nEach tool is defined by a unique `name`, `title`, `description` and an `inputSchema` (JSON Schema describing expected parameters):contentReference[oaicite:32]{index=32}.  Tools may optionally specify an `outputSchema` in the specification.  Clients list available tools via `tools/list` and then call a tool using `tools/call` with the tool name and arguments:\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"weather_current\",\n    \"arguments\": {\n      \"location\": \"San Francisco\",\n      \"units\": \"imperial\"\n    }\n  }\n}\n````\n\nA tool returns an array of **content objects** that may include text, images, audio or structured data.  Responses also indicate whether an error occurred.  Tools must be idempotent and safe; hosts require user confirmation before execution.\n\n### Notifications\n\nServers that declared `listChanged: true` may proactively send a notification when their tool list changes:\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/tools/list_changed\"\n}\n```\n\nClients should then send `tools/list` again to refresh their registry.  Notifications are one\u2011way messages and **must not** include an `id`.  They help maintain real\u2011time synchronisation without polling.\n\n## MCP Primitives \u2013 Client Side (For Awareness)\n\nAlthough server developers primarily focus on server primitives, understanding client features helps design richer interactions:\n\n* **Elicitation** \u2013 Allows a server to request additional user input when needed.  The server sends an `elicitation/requestInput` message containing a prompt and JSON Schema of expected fields.  The user responds through the host UI and the client relays the data back.  Use elicitation to confirm bookings or gather additional parameters (e.g., seat preference) during long workflows.\n\n* **Roots** \u2013 The client exposes filesystem boundaries to the server via `roots/list`.  Each root is a `file://` URI with a name, indicating directories where the server may operate.  Roots help servers understand project boundaries while clients retain access control.\n\n* **Sampling** \u2013 Lets a server ask the client\u2019s LLM to run a completion with a set of messages and model preferences.  Sampling is useful for tasks that require AI reasoning (e.g., choosing the best flight) without embedding an LLM in the server.  The client always seeks user approval and may reveal or redact sensitive data.\n\n## Message Structure and JSON\u2011RPC Rules\n\nMCP relies on the **JSON\u2011RPC 2.0** message format for all requests, responses and notifications.  Important rules include:\n\n* **Requests** must include a `jsonrpc` field with value \"2.0\", a non\u2011null `id` unique within the session, a `method` string and optional `params` object.\n* **Responses** must use the same `id` as the corresponding request and include either a `result` or `error` object, but not both.  Errors must include a numeric code and message.\n* **Notifications** are messages without an `id`; they never expect a response.\n* The `_meta` field allows attaching additional metadata.  Keys may be namespaced and certain prefixes (`modelcontextprotocol`, `mcp`) are reserved for protocol use.\n\n## Developing a Server\n\n### Choosing an SDK\n\nOfficial SDKs exist in TypeScript, Python, Go, Kotlin, Swift, Java, C#, Ruby, Rust and PHP.  Each SDK supports server features (tools, resources, prompts), client features, local/remote transports and type\u2011safe protocol implementations.  Choose an SDK that matches your language preferences and environment.\n\n### Example: Python Weather Server (using `mcp.server.fastMCP`)\n\n1. **Environment setup** \u2013 The quickstart suggests installing the `uv` packaging tool and creating a virtual environment.  On macOS/Linux:\n\n   ```bash\n   curl -LsSf https://astral.sh/uv/install.sh | sh\n   uv init weather\n   cd weather\n   uv venv && source .venv/bin/activate\n   uv add \"mcp[cli]\" httpx\n   touch weather.py\n   ```\n2. **Create the server instance** \u2013 Import required modules and create a `FastMCP` server instance.  Define constants such as API endpoints and user agent:\n   ```python\n   from typing import Any\n   import httpx\n   from mcp.server.fastmcp import FastMCP\n\n   mcp = FastMCP(\"weather\")\n   NWS_API_BASE = \"https://api.weather.gov\"\n   USER_AGENT   = \"weather-app/1.0\"\n   ```\n3. **Helper functions** \u2013 Write helper functions to fetch and format data.  For example, call the National Weather Service (NWS) API using `httpx`, handle errors and format responses into strings.\n\n4. **Define tools** \u2013 Decorate asynchronous functions with `@mcp.tool()` to automatically register them as MCP tools.  Provide docstrings and type annotations; the SDK uses them to generate the tool description and input schema.  For example, implement `get_alerts(state: str) -> str` to fetch weather alerts for a U.S. state and `get_forecast(latitude: float, longitude: float) -> str` to return the forecast for a location.\n\n5. **Run the server** \u2013 Start the server using the stdio transport.  The `mcp.run(transport='stdio')` call will listen for JSON\u2011RPC messages on stdin and write responses to stdout.  **Important:** never write to standard output directly (e.g., using `print()`), as this corrupts the message stream.  Instead, use a logging library that writes to stderr.\n\n6. **Testing** \u2013 For hosts like Claude Desktop, update the configuration file to specify the command needed to start your server (e.g., `uv run weather.py`) and the server name.  Restart the host to pick up the configuration, and then verify that the tools appear in the UI.\n\n### Best Practices and Guidelines\n\n* **Logging:** For stdio transports, all logs must be sent to *stderr* to avoid mixing with JSON\u2011RPC output.  Use structured logging so clients can display logs effectively.\n* **Error handling:** Use `None`/null returns or raise exceptions to return user\u2011friendly error messages.  Provide clear descriptions in error responses.\n* **Security:** Implement robust consent flows; hosts must always ask users before executing tools or sending data.  Follow privacy and trust\u2011and\u2011safety principles: user consent, data privacy, tool safety, and sampling controls.  Do not request or transmit passwords or other sensitive information; rely on host\u2011provided credentials.\n* **Capability declaration:** During initialization, accurately declare your server\u2019s capabilities and sub\u2011capabilities (e.g., set `listChanged: true` if you intend to send change notifications).  Undeclared capabilities cannot be used in the session.\n* **Tool design:** Use descriptive names, titles and descriptions.  Provide complete JSON Schemas for inputs (and outputs when appropriate).  Tools should be idempotent and minimize side effects.  Avoid exposing functions that can cause harm or leak sensitive data without explicit user confirmation.\n* **Resource design:** When exposing resources, use clear and intuitive URI schemes.  Provide MIME types and support templates for dynamic queries.  Use `resources/subscribe` if resource data can change frequently.\n* **Prompt design:** Keep prompts simple and parameterised.  Use them to orchestrate multi\u2011step workflows by combining resources and tools.  Provide descriptions and argument definitions to enable UI validation.\n* **Notifications:** Use notifications sparingly to inform clients of changes.  Ensure that clients have subscribed (via capability negotiation) before sending notifications.\n\n## Conclusion\n\nBuilding an MCP server involves understanding the protocol\u2019s lifecycle, message formats and primitives.  Servers expose tools, resources and prompts; negotiate capabilities with clients; and respect user consent and security guidelines.  The official SDKs simplify much of the boilerplate, allowing developers to focus on business logic.  By following the principles outlined in the documentation\u2014such as proper version negotiation, logging practices, capability declaration, and trust\u2011and\u2011safety considerations\u2014you can create powerful integrations that seamlessly extend AI applications while keeping users in control.\n",
  "path": "docs/mcp-guidelines.md",
  "tags": [
    "mcp",
    "compliance",
    "guidelines"
  ],
  "title": "MCP Guidelines",
  "type": "product_context"
}
```

---
### guidelines/mcp

*   [2025-09-18 01:43:33]

*   [2025-09-27 20:29:36]

```json
{
  "content": "---\ntype: product_context\ntitle: MCP Guidelines\ntags: [mcp, compliance, guidelines]\n---\n\n# Guide to Building an MCP Server (Model Context Protocol)\n\n## Introduction\n\nThe **Model Context Protocol (MCP)** is an open standard that allows AI applications (called *hosts*) such as Claude Desktop or ChatGPT to discover context data and safely call functions exposed by external systems.  The protocol decouples AI clients from specific data sources and tools by defining a JSON\u2011RPC\u2013based interface for exchanging context and invoking actions.  An MCP **server** is a program that provides tools, resources and prompts to a host through an **MCP client**.  A **client** is a connector embedded in the host which maintains a dedicated connection to a single server and translates between JSON\u2011RPC messages and host\u2011specific APIs:contentReference[oaicite:0]{index=0}.  Multiple clients can be active within a host to communicate with different servers:contentReference[oaicite:1]{index=1}.\n\nThis guide synthesises the official documentation and specification to provide server developers with a concise reference.  It covers the architecture, lifecycle, primitives, message flows and best practices needed to build a compliant server.\n\n## Architecture and Participants\n\nMCP follows a **client\u2011server architecture** with three actors:contentReference[oaicite:2]{index=2}:\n\n| Actor | Role |\n|---|---|\n| **Host** | The AI application (e.g., IDE, chat\u2011assistant) that spawns clients and orchestrates interactions. |\n| **Client** | A connection manager running inside the host that talks to exactly one server.  It negotiates capabilities, translates user interactions into JSON\u2011RPC requests and enforces user permissions. |\n| **Server** | A separate program that provides context and functionality via MCP.  It may run locally or remotely and communicates only through JSON\u2011RPC messages. |\n\nMCP splits functionality into two **layers**:contentReference[oaicite:3]{index=3}:\n\n1. **Data layer** \u2013 a JSON\u2011RPC 2.0 exchange protocol that defines message structures for connection lifecycle, primitives (tools, resources and prompts), client\u2011initiated features (sampling, elicitation, logging) and notifications.  This layer defines what messages exist and when they are valid:contentReference[oaicite:4]{index=4}.\n2. **Transport layer** \u2013 responsible for moving JSON\u2011RPC messages between participants.  The two official transports are **stdio** (for local processes) and **streamable HTTP** (for remote servers).  StdIO is faster and uses process pipes; HTTP uses POST requests and optional Server\u2011Sent Events for streaming responses, with support for bearer tokens, API keys or OAuth:contentReference[oaicite:5]{index=5}.\n\n### Scope and Projects\n\nThe protocol comprises a specification, SDKs in multiple languages, development tools (e.g., an **MCP Inspector**) and reference servers:contentReference[oaicite:6]{index=6}.  The standard only defines how context and tool calls are exchanged; how the host uses this context (e.g., summarising long documents) is out of scope:contentReference[oaicite:7]{index=7}.\n\n## Lifecycle Management\n\nMCP connections are **stateful**; therefore server and client must negotiate capabilities and protocol version before any operation.  The lifecycle consists of three phases:contentReference[oaicite:8]{index=8}:\n\n1. **Initialisation** \u2013 The client sends an `initialize` request specifying the protocol version it understands, its capabilities (e.g., ability to handle elicitation or sampling) and client metadata:contentReference[oaicite:9]{index=9}.  The server responds with its supported protocol version, capabilities and server metadata:contentReference[oaicite:10]{index=10}.  Once agreed, the client sends a `notifications/initialized` message to signal readiness:contentReference[oaicite:11]{index=11}.  During this phase clients and servers **must not** send other requests apart from pings or logging messages:contentReference[oaicite:12]{index=12}.\n2. **Operation** \u2013 After initialization, both parties can send requests or notifications defined by the capabilities negotiated.  They must use the same protocol version throughout the session:contentReference[oaicite:13]{index=13}.\n3. **Shutdown** \u2013 The connection terminates gracefully.  There are no special shutdown messages; the transport (closing stdio streams or HTTP connections) signals termination:contentReference[oaicite:14]{index=14}.\n\n### Version Negotiation\n\nProtocol revisions are strings like `YYYY\u2011MM\u2011DD` and indicate the last date of backward\u2011incompatible changes:contentReference[oaicite:15]{index=15}.  During initialisation the client proposes a version; if the server supports it, it responds with the same version; otherwise it can reply with the latest version it supports:contentReference[oaicite:16]{index=16}.  If a common version cannot be found, the connection should be closed:contentReference[oaicite:17]{index=17}.  For HTTP transports, every request must include an `MCP\u2011Protocol\u2011Version` header with the negotiated version:contentReference[oaicite:18]{index=18}.\n\n### Capability Negotiation\n\nCapabilities define optional features of the protocol.  During initialisation, the client advertises capabilities it supports (roots, sampling, elicitation, etc.), and the server advertises the features it offers (tools, resources, prompts, logging, completions, etc.):contentReference[oaicite:19]{index=19}.  Each capability can include sub\u2011capabilities like `listChanged` (server will send update notifications) or `subscribe` (client can subscribe to resource changes).  Only capabilities that both sides declare are allowed during the session:contentReference[oaicite:20]{index=20}.\n\n## MCP Primitives \u2013 Server Side\n\nA server exposes **three core primitives**:contentReference[oaicite:21]{index=21}:\n\n1. **Tools** \u2013 Executable functions that perform actions, such as database queries or API calls.  Tools are model\u2011controlled; the language model decides when to call them based on user prompts.  Each tool is described using JSON Schema (input parameters and optional output schema) and is uniquely named:contentReference[oaicite:22]{index=22}.  Tools can be invoked via the `tools/call` method.  Servers may also send `notifications/tools/list_changed` to inform clients when tools are added or removed:contentReference[oaicite:23]{index=23}.  The specification requires that tools be safe \u2013 the host must always seek explicit user approval before executing a tool:contentReference[oaicite:24]{index=24}.\n\n2. **Resources** \u2013 Read\u2011only data that provide context to AI models.  Resources may represent file contents, database records, or API responses.  Each resource has a URI (e.g., `file:///path/to/file.md`) and MIME type.  There are **direct resources**, which have fixed URIs, and **resource templates**, which include parameters (e.g., `travel://activities/{city}/{category}`) to allow flexible queries:contentReference[oaicite:25]{index=25}.  Resources are discovered via `resources/list` or `resources/templates/list` and read via `resources/read`:contentReference[oaicite:26]{index=26}.  Optional `resources/subscribe` allows clients to subscribe to changes:contentReference[oaicite:27]{index=27}.  Servers can use resources to supply context to the model, but the host decides how to select and deliver the data:contentReference[oaicite:28]{index=28}.\n\n3. **Prompts** \u2013 Pre\u2011built templates that guide the model through tasks.  Prompts can have structured arguments and may reference tools and resources to create domain workflows:contentReference[oaicite:29]{index=29}.  They are discovered via `prompts/list` and retrieved with `prompts/get`; they are never auto\u2011invoked by the model and always require explicit user initiation:contentReference[oaicite:30]{index=30}.  Parameter completion helps users discover valid argument values:contentReference[oaicite:31]{index=31}.\n\n### Tool Definition and Usage\n\nEach tool is defined by a unique `name`, `title`, `description` and an `inputSchema` (JSON Schema describing expected parameters):contentReference[oaicite:32]{index=32}.  Tools may optionally specify an `outputSchema` in the specification.  Clients list available tools via `tools/list` and then call a tool using `tools/call` with the tool name and arguments:\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 3,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"weather_current\",\n    \"arguments\": {\n      \"location\": \"San Francisco\",\n      \"units\": \"imperial\"\n    }\n  }\n}\n````\n\nA tool returns an array of **content objects** that may include text, images, audio or structured data.  Responses also indicate whether an error occurred.  Tools must be idempotent and safe; hosts require user confirmation before execution.\n\n### Notifications\n\nServers that declared `listChanged: true` may proactively send a notification when their tool list changes:\n\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"notifications/tools/list_changed\"\n}\n```\n\nClients should then send `tools/list` again to refresh their registry.  Notifications are one\u2011way messages and **must not** include an `id`.  They help maintain real\u2011time synchronisation without polling.\n\n## MCP Primitives \u2013 Client Side (For Awareness)\n\nAlthough server developers primarily focus on server primitives, understanding client features helps design richer interactions:\n\n* **Elicitation** \u2013 Allows a server to request additional user input when needed.  The server sends an `elicitation/requestInput` message containing a prompt and JSON Schema of expected fields.  The user responds through the host UI and the client relays the data back.  Use elicitation to confirm bookings or gather additional parameters (e.g., seat preference) during long workflows.\n\n* **Roots** \u2013 The client exposes filesystem boundaries to the server via `roots/list`.  Each root is a `file://` URI with a name, indicating directories where the server may operate.  Roots help servers understand project boundaries while clients retain access control.\n\n* **Sampling** \u2013 Lets a server ask the client\u2019s LLM to run a completion with a set of messages and model preferences.  Sampling is useful for tasks that require AI reasoning (e.g., choosing the best flight) without embedding an LLM in the server.  The client always seeks user approval and may reveal or redact sensitive data.\n\n## Message Structure and JSON\u2011RPC Rules\n\nMCP relies on the **JSON\u2011RPC 2.0** message format for all requests, responses and notifications.  Important rules include:\n\n* **Requests** must include a `jsonrpc` field with value \"2.0\", a non\u2011null `id` unique within the session, a `method` string and optional `params` object.\n* **Responses** must use the same `id` as the corresponding request and include either a `result` or `error` object, but not both.  Errors must include a numeric code and message.\n* **Notifications** are messages without an `id`; they never expect a response.\n* The `_meta` field allows attaching additional metadata.  Keys may be namespaced and certain prefixes (`modelcontextprotocol`, `mcp`) are reserved for protocol use.\n\n## Developing a Server\n\n### Choosing an SDK\n\nOfficial SDKs exist in TypeScript, Python, Go, Kotlin, Swift, Java, C#, Ruby, Rust and PHP.  Each SDK supports server features (tools, resources, prompts), client features, local/remote transports and type\u2011safe protocol implementations.  Choose an SDK that matches your language preferences and environment.\n\n### Example: Python Weather Server (using `mcp.server.fastMCP`)\n\n1. **Environment setup** \u2013 The quickstart suggests installing the `uv` packaging tool and creating a virtual environment.  On macOS/Linux:\n\n   ```bash\n   curl -LsSf https://astral.sh/uv/install.sh | sh\n   uv init weather\n   cd weather\n   uv venv && source .venv/bin/activate\n   uv add \"mcp[cli]\" httpx\n   touch weather.py\n   ```\n2. **Create the server instance** \u2013 Import required modules and create a `FastMCP` server instance.  Define constants such as API endpoints and user agent:\n   ```python\n   from typing import Any\n   import httpx\n   from mcp.server.fastmcp import FastMCP\n\n   mcp = FastMCP(\"weather\")\n   NWS_API_BASE = \"https://api.weather.gov\"\n   USER_AGENT   = \"weather-app/1.0\"\n   ```\n3. **Helper functions** \u2013 Write helper functions to fetch and format data.  For example, call the National Weather Service (NWS) API using `httpx`, handle errors and format responses into strings.\n\n4. **Define tools** \u2013 Decorate asynchronous functions with `@mcp.tool()` to automatically register them as MCP tools.  Provide docstrings and type annotations; the SDK uses them to generate the tool description and input schema.  For example, implement `get_alerts(state: str) -> str` to fetch weather alerts for a U.S. state and `get_forecast(latitude: float, longitude: float) -> str` to return the forecast for a location.\n\n5. **Run the server** \u2013 Start the server using the stdio transport.  The `mcp.run(transport='stdio')` call will listen for JSON\u2011RPC messages on stdin and write responses to stdout.  **Important:** never write to standard output directly (e.g., using `print()`), as this corrupts the message stream.  Instead, use a logging library that writes to stderr.\n\n6. **Testing** \u2013 For hosts like Claude Desktop, update the configuration file to specify the command needed to start your server (e.g., `uv run weather.py`) and the server name.  Restart the host to pick up the configuration, and then verify that the tools appear in the UI.\n\n### Best Practices and Guidelines\n\n* **Logging:** For stdio transports, all logs must be sent to *stderr* to avoid mixing with JSON\u2011RPC output.  Use structured logging so clients can display logs effectively.\n* **Error handling:** Use `None`/null returns or raise exceptions to return user\u2011friendly error messages.  Provide clear descriptions in error responses.\n* **Security:** Implement robust consent flows; hosts must always ask users before executing tools or sending data.  Follow privacy and trust\u2011and\u2011safety principles: user consent, data privacy, tool safety, and sampling controls.  Do not request or transmit passwords or other sensitive information; rely on host\u2011provided credentials.\n* **Capability declaration:** During initialization, accurately declare your server\u2019s capabilities and sub\u2011capabilities (e.g., set `listChanged: true` if you intend to send change notifications).  Undeclared capabilities cannot be used in the session.\n* **Tool design:** Use descriptive names, titles and descriptions.  Provide complete JSON Schemas for inputs (and outputs when appropriate).  Tools should be idempotent and minimize side effects.  Avoid exposing functions that can cause harm or leak sensitive data without explicit user confirmation.\n* **Resource design:** When exposing resources, use clear and intuitive URI schemes.  Provide MIME types and support templates for dynamic queries.  Use `resources/subscribe` if resource data can change frequently.\n* **Prompt design:** Keep prompts simple and parameterised.  Use them to orchestrate multi\u2011step workflows by combining resources and tools.  Provide descriptions and argument definitions to enable UI validation.\n* **Notifications:** Use notifications sparingly to inform clients of changes.  Ensure that clients have subscribed (via capability negotiation) before sending notifications.\n\n## Conclusion\n\nBuilding an MCP server involves understanding the protocol\u2019s lifecycle, message formats and primitives.  Servers expose tools, resources and prompts; negotiate capabilities with clients; and respect user consent and security guidelines.  The official SDKs simplify much of the boilerplate, allowing developers to focus on business logic.  By following the principles outlined in the documentation\u2014such as proper version negotiation, logging practices, capability declaration, and trust\u2011and\u2011safety considerations\u2014you can create powerful integrations that seamlessly extend AI applications while keeping users in control.\n",
  "path": "docs/mcp-guidelines.md",
  "tags": [
    "mcp",
    "compliance",
    "guidelines"
  ],
  "title": "MCP Guidelines",
  "type": "product_context"
}
```
