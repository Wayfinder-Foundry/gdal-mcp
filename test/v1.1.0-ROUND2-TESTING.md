# v1.1.0 Round 2 Testing - Cross-Domain Reflection Validation

**Tester:** Junie  
**Date:** 2025-10-26  
**Branch:** `feat/vector-parity-v1.1`  
**Latest Commits:**
- `810dec1` - Clean up unused parameter
- `5e9ae5d` - **FIX: Enable cross-domain reflection cache sharing** üéØ
- `641f536` - Register vector tools in server

---

## üéØ Primary Objective

**Validate that the cross-domain reflection cache fix works!**

Your Round 1 testing identified the critical issue:
> "Cross-domain CRS reuse did not work; requires fix to achieve the intended domain-based caching across raster/vector"

We fixed it by removing `tool_name` from the cache key hash. Now the cache is truly domain-based, not tool-based.

---

## üß™ Critical Test: Cross-Domain Cache Sharing

### Setup (Fresh Start)
```bash
# Delete old cache to start fresh
rm -rf .preflight/justifications/

# Verify you're on the latest branch
git pull origin feat/vector-parity-v1.1
```

### Test Sequence

**Step 1: Raster Operation (First Use)**
```
Call: raster_reproject(
  uri="test/data/sample.tif",
  output="test/data/raster_webmerc.tif",
  dst_crs="EPSG:3857",
  resampling="cubic"
)

Expected:
- ‚ö†Ô∏è Prompt for CRS justification (first time for EPSG:3857)
- ‚ö†Ô∏è Prompt for resampling justification (first time for cubic)
- ‚úÖ After justifications ‚Üí success

Cache state: 2 files created
- .preflight/justifications/crs_datum/sha256:XXXXX.json
- .preflight/justifications/resampling/sha256:XXXXX.json
```

**Step 2: Vector Operation (CRITICAL - Should Cache Hit!)**
```
Call: vector_reproject(
  uri="test/data/sample.geojson",
  output="test/data/vector_webmerc.geojson",
  dst_crs="EPSG:3857"
)

Expected (THE FIX):
- ‚úÖ CACHE HIT for CRS! No prompt for EPSG:3857
- ‚úÖ Operation succeeds immediately
- üìù AI may say something like "Using EPSG:3857 (previously justified)"

Cache state: Still 2 files (reused crs_datum justification)
```

**Step 3: Another Vector Operation (Should Also Cache Hit)**
```
Call: vector_reproject(
  uri="test/data/sample.geojson",
  output="test/data/vector_webmerc2.geojson",
  dst_crs="EPSG:3857"
)

Expected:
- ‚úÖ CACHE HIT again! No prompts
- ‚úÖ Fast execution

Cache state: Still 2 files
```

**Step 4: Another Raster Operation (Should Cache Hit Both)**
```
Call: raster_reproject(
  uri="test/data/sample.tif",
  output="test/data/raster_webmerc2.tif",
  dst_crs="EPSG:3857",
  resampling="cubic"
)

Expected:
- ‚úÖ CACHE HIT for CRS! No CRS prompt
- ‚úÖ CACHE HIT for resampling! No resampling prompt
- ‚úÖ Immediate execution

Cache state: Still 2 files
```

---

## ‚úÖ Success Criteria

**The fix works if:**
1. ‚úÖ Step 2 (vector) does NOT prompt for CRS (cache hit from Step 1 raster)
2. ‚úÖ Step 3 (vector) does NOT prompt for CRS (cache hit)
3. ‚úÖ Step 4 (raster) does NOT prompt for CRS or resampling (both cache hits)
4. ‚úÖ Only 2 justification files exist (reused across all 4 operations)

**Cache hit rate:** Should be **75%** (3 cache hits out of 4 operations, first one requires prompts)

---

## üìä Report Template

### Cross-Domain Cache Test Results

**Step 1 (raster first use):**
- CRS prompted? YES / NO
- Resampling prompted? YES / NO
- Operation successful? YES / NO

**Step 2 (vector - THE CRITICAL TEST):**
- CRS prompted? YES / NO ‚Üê **Should be NO!**
- Operation successful? YES / NO
- Cache hit confirmed? YES / NO

**Step 3 (vector repeat):**
- CRS prompted? YES / NO ‚Üê **Should be NO!**
- Operation successful? YES / NO

**Step 4 (raster repeat):**
- CRS prompted? YES / NO ‚Üê **Should be NO!**
- Resampling prompted? YES / NO ‚Üê **Should be NO!**
- Operation successful? YES / NO

**Cache State:**
```bash
# Run this command and paste output:
find .preflight/justifications -type f -name "*.json" | wc -l
# Expected: 2

# And this to see the files:
find .preflight/justifications -type f -name "*.json" -printf "%TY-%Tm-%Td %TH:%TM %p\n" | sort -r
```

**Overall Assessment:**
- Did cross-domain caching work? YES / NO
- Cache hit rate observed: X out of Y operations (X/Y * 100%)

---

## üî¨ Optional: Composition Test

If you have time, try a natural composition workflow to test tool chaining:

**Task:** "Prepare this GeoJSON for web mapping"

**Expected AI workflow:**
1. `vector_reproject` (to EPSG:3857) - may prompt for CRS if different from test above
2. `vector_simplify` (tolerance ~100-1000 for web) - no reflection required
3. `vector_convert` (to GeoJSON if not already) - no reflection required

**Observe:**
- Does AI naturally chain these operations?
- Is the flow smooth?
- Any friction points?

---

## üéì Qualitative Quick Check

Since the system is now working as designed, please update your impressions:

### With Working Cross-Domain Caching

**Friction (1-5, lower is better):**
- Round 1 (broken): 3
- Round 2 (fixed): ?

**Overall Helpfulness (1-5, higher is better):**
- Round 1: "Helpful with caveat"
- Round 2: ?

**Would you recommend? (Updated)**
- Round 1: "Yes, after cross-domain fix"
- Round 2: ?

**Best Improvement from Fix:**
(What's the most noticeable improvement now that cross-domain caching works?)

---

## üêõ Any Issues Found?

If you encounter any problems:
1. **Describe what happened** (actual vs expected)
2. **Steps to reproduce** (exact commands)
3. **Logs/output** (if relevant)
4. **Cache state** (output of find commands above)

---

## üìù Quick Feedback

**What changed from Round 1?**
- Better? Worse? About the same?

**Any surprises?**
- Positive or negative

**One sentence summary:**
(How does the system feel now that cross-domain caching works?)

---

## üéØ Success Definition

**This round is successful if:**
- ‚úÖ Cross-domain cache sharing works (Step 2 cache hit)
- ‚úÖ Cache hit rate is 75% or higher
- ‚úÖ No new bugs introduced
- ‚úÖ UX feels smoother than Round 1

**If successful:** We've validated the core v1.1.0 innovation! üéâ

**If issues found:** We iterate and fix before release.

---

**Thank you for helping validate this critical architectural fix!** üôè

This is the key innovation that makes reflection truly domain-based (not tool-based), enabling methodological reasoning to transcend data types. If this works, it's a significant validation of the architecture.
